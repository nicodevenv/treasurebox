<?php

namespace App\Tests\Service;

use App\Entities\AdventurerOption;
use App\Entities\Map;
use App\Entities\TreasureOption;
use App\Service\AdventurerService;
use App\Tests\AbstractTestCase;

class AdventurerServiceTest extends AbstractTestCase
{
    /** @var AdventurerService */
    private $subject;

    /** @var  AdventurerOption */
    private $adventurer;

    /** @var  Map */
    private $map;

    public function setUp()
    {
        $this->subject = new AdventurerService();

        $this->map = new Map(5, 5);

        $adventurerData   = [
            'x'         => '1',
            'y'         => '1',
            'direction' => 'O',
            'name'      => 'Nicolas',
            'actions'   => 'AAGDGDA',
        ];
        $this->adventurer = new AdventurerOption($adventurerData, $this->map);

        parent::setUp(); // TODO: Change the autogenerated stub
    }

    public function testAddTreasure()
    {
        // Assert new Treasure on adventurer
        $treasureData = [
            'x'       => 1,
            'y'       => 1,
            'counter' => 2,
        ];
        $treasure     = new TreasureOption($treasureData, $this->map);

        $this->subject->addTreasure($this->adventurer, $treasure);

        $attemptedTreasure = new TreasureOption([
            'counter' => 1,
            'x'       => 1,
            'y'       => 1,
        ], $this->map);

        $this->assertEquals($attemptedTreasure, $this->adventurer->getTreasures()[0]);

        // Assert add 1 more on Treasure's counter of adventurer
        $this->subject->addTreasure($this->adventurer, $treasure);

        $attemptedTreasure = new TreasureOption([
            'counter' => 2,
            'x'       => 1,
            'y'       => 1,
        ], $this->map);

        $this->assertEquals($attemptedTreasure, $this->adventurer->getTreasures()[0]);

        // Throw exception if positions are different between Adventurer and Treasure
        $treasureData = [
            'x'       => 1,
            'y'       => 2,
            'counter' => 2,
        ];
        $treasure     = new TreasureOption($treasureData, $this->map);
        $this->expectException(\Exception::class);
        $this->subject->addTreasure($this->adventurer, $treasure);
    }

    /**
     * @return array
     */
    public function getNextPositionProvider(): array
    {
        return [
            [['x' => 1, 'y' => 0], 'N'], // Go North
            [['x' => 1, 'y' => 2], 'S'], // Go South
            [['x' => 0, 'y' => 1], 'O'], // Go West
            [['x' => 2, 'y' => 1], 'E'], // Go East
        ];
    }

    /**
     * @dataProvider getNextPositionProvider
     *
     * @param array  $attempted
     * @param string $direction
     */
    public function testGetNextPosition(array $attempted, string $direction)
    {
        $this->adventurer->setDirection($direction);
        $this->assertEquals($attempted, $this->subject->getNextPosition($this->adventurer));
    }

    /**
     * @return array
     */
    public function moveProvider(): array
    {
        return [
            [1, 0, 'N'], // Go North
            [1, 2, 'S'], // Go South
            [0, 1, 'O'], // Go West
            [2, 1, 'E'], // Go East
        ];
    }

    /**
     * @dataProvider moveProvider
     *
     * @param int    $x
     * @param int    $y
     * @param string $direction
     */
    public function testMove(int $x, int $y, string $direction)
    {
        $this->adventurer->setDirection($direction);
        $this->subject->move($this->adventurer);

        $this->assertEquals($x, $this->adventurer->getX());
        $this->assertEquals($y, $this->adventurer->getY());
    }

    public function getNextDirectionProvider()
    {
        return [
            // Turn right
            ['N', 'E', 'D', false],
            ['E', 'S', 'D', false],
            ['S', 'O', 'D', false],
            ['O', 'N', 'D', false],
            // Turn left
            ['N', 'O', 'G', false],
            ['O', 'S', 'G', false],
            ['S', 'E', 'G', false],
            ['E', 'N', 'G', false],
            // select first on left turn (N -> O)
            ['N', 'N', 'D', true],
            ['E', 'N', 'D', true],
            ['S', 'N', 'D', true],
            ['O', 'N', 'D', true],
            // select first on left turn (reverse O -> N)
            ['N', 'O', 'G', true],
            ['E', 'O', 'G', true],
            ['S', 'O', 'G', true],
            ['O', 'O', 'G', true],
        ];
    }

    /**
     * @param $direction
     * @param $attemptedDirection
     * @param $selectFirst
     * @dataProvider getNextDirectionProvider
     */
    public function testGetNextDirection($direction, $attemptedDirection, $turnTo, $selectFirst)
    {
        $this->adventurer->setDirection($direction);
        $this->assertEquals($attemptedDirection, $this->subject->getNextDirection($this->adventurer, $turnTo, $selectFirst));

        if (!$selectFirst) {
            $this->subject->turn($this->adventurer, $turnTo);
            $this->assertEquals($attemptedDirection, $this->adventurer->getDirection());
        }
    }
}